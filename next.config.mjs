import path from "path";
import { generateScopedName, hash } from "@camome/utils";
import { withContentlayer } from "next-contentlayer";
import createMdx from "@next/mdx";
import remarkGfm from "remark-gfm";
import rehypeExternalLinks from "rehype-external-links";
import rehypePrismPlus from "rehype-prism-plus";
import svgrRules from "./webpack/svgr.mjs";
import mdxOptions from "./src/lib/mdxOptions.mjs";

/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  swcMinify: true,
  pageExtensions: ["ts", "tsx", "md", "mdx"],
  transpilePackages: ["@camome/core"],
  images: {
    unoptimized: process.env.EXPORT_MODE === "true",
  },
  experimental: {
    scrollRestoration: true,
  },
  webpack: (config) => {
    // define class names generated by css-modules
    config.module.rules
      .find(({ oneOf }) => !!oneOf)
      .oneOf.filter(({ use }) => JSON.stringify(use)?.includes("css-loader"))
      .reduce((acc, { use }) => acc.concat(use), [])
      .forEach(({ options }) => {
        if (options.modules) {
          options.modules.getLocalIdent = (
            context,
            localIdentName,
            localName
          ) => {
            const filename = context.resourcePath;
            // @camome/core depends on static class names
            // but your own module classes won't.
            if (!filename.match(/@camome\/core/)) {
              // Whatever. `hash()` doesn't have any special effect.
              return localName + "-" + hash(filename);
            }
            return generateScopedName(localName, context.resourcePath);
          };
        }
      });
    config.module.rules.push(svgrRules);

    // https://github.com/contentlayerdev/contentlayer/issues/313#issuecomment-1279678289
    config.infrastructureLogging = {
      level: "error",
    };

    config.resolve.alias = {
      ...config.resolve.alias,
      "@/*": "./src/*",
      "@/content/*": "./content/*",
      "@/public/*": "./public/*",
    };

    return config;
  },
};

const withMdx = createMdx({
  extension: /\.mdx?$/,
  options: mdxOptions,
});

export default withContentlayer(withMdx(nextConfig));
